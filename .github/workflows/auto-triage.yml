name: Auto Triage

on:
  issues:
    types: [opened, edited, reopened]
  pull_request_target:
    types: [opened, edited, reopened, synchronize]

permissions:
  issues: write
  pull-requests: write

jobs:
  assign-and-label:
    runs-on: ubuntu-latest
    steps:
      - name: Assign and label
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const fixedAssignee = 'maehwasoo';
            const labelMap = {
              feat: 'ðŸ’« Feature',
              fix: 'ðŸ”§ Fix',
              docs: 'ðŸ“„ Docs',
              refactor: 'ðŸ› ï¸ Refactor',
              style: 'ðŸŽ¨ Style',
              test: 'ðŸ§ª Test',
              chore: 'âš™ï¸ Setting',
              deploy: 'ðŸŒ Deploy',
            };
            const typeLabels = new Set(Object.values(labelMap));

            const isIssue = context.eventName === 'issues';
            const isPullRequest = context.eventName === 'pull_request_target';
            if (!isIssue && !isPullRequest) {
              console.log(`Unsupported event: ${context.eventName}`);
              process.exit(0);
            }

            const number = isIssue
              ? context.payload.issue.number
              : context.payload.pull_request.number;
            const title = isIssue
              ? context.payload.issue.title ?? ''
              : context.payload.pull_request.title ?? '';

            if (isIssue && context.payload.issue.pull_request) {
              console.log('Skipping: issues event for a pull request.');
              process.exit(0);
            }

            try {
              await github.rest.issues.addAssignees({
                owner,
                repo,
                issue_number: number,
                assignees: [fixedAssignee],
              });
            } catch (error) {
              console.log('Failed to add assignee:', error?.message ?? error);
            }

            const match = title.match(/^\[(feat|fix|docs|refactor|style|test|chore|deploy)\]/i);
            const type = match?.[1]?.toLowerCase();
            const targetLabel = type ? labelMap[type] : null;

            if (!targetLabel) {
              console.log('No recognized type prefix; leaving labels unchanged.');
              process.exit(0);
            }

            const currentLabels = await github.paginate(
              github.rest.issues.listLabelsOnIssue,
              { owner, repo, issue_number: number, per_page: 100 }
            );
            const currentLabelNames = currentLabels.map((l) => l.name);

            for (const name of currentLabelNames) {
              if (typeLabels.has(name) && name !== targetLabel) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: number,
                    name,
                  });
                } catch (error) {
                  console.log(`Failed to remove label "${name}":`, error?.message ?? error);
                }
              }
            }

            if (!currentLabelNames.includes(targetLabel)) {
              try {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: number,
                  labels: [targetLabel],
                });
              } catch (error) {
                console.log(`Failed to add label "${targetLabel}":`, error?.message ?? error);
              }
            }
